<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>UE5 | Academic</title>
    <link>https://example.com/tag/ue5/</link>
      <atom:link href="https://example.com/tag/ue5/index.xml" rel="self" type="application/rss+xml" />
    <description>UE5</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Fri, 27 May 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://example.com/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>UE5</title>
      <link>https://example.com/tag/ue5/</link>
    </image>
    
    <item>
      <title>Пост по прошлой неделе</title>
      <link>https://example.com/post/%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D0%BE-%D0%BF%D1%80%D0%BE%D1%88%D0%BB%D0%BE%D0%B8-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5-4/</link>
      <pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/post/%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D0%BE-%D0%BF%D1%80%D0%BE%D1%88%D0%BB%D0%BE%D0%B8-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5-4/</guid>
      <description>&lt;h2 id=&#34;что-такое-файл-конфигурации&#34;&gt;Что такое файл конфигурации?&lt;/h2&gt;
&lt;p&gt;Файлы конфигурации - текстовые файлы, содержащие настройки свойств для настройки игрового процесса или поведения движка.&lt;/p&gt;
&lt;h2 id=&#34;для-чего-используют-файлы-конфигурации&#34;&gt;Для чего используют файлы конфигурации?&lt;/h2&gt;
&lt;p&gt;Файлы конфигурации можно использовать для установки значений свойств, которые будут инициализированы при загрузке проекта. Конфигурация определяется парами ключ-значение, расположенными в разделах. Одно или несколько значений могут быть связаны с данным ключом.&lt;/p&gt;
&lt;p&gt;Файлы конфигурации механизма используются для значений объектов и переменных по умолчанию. Конфигурация пользовательского ввода может использоваться для привязки клавиш. По умолчанию файлы DefaultEngine.ini и DefaultGame.ini создаются при создании нового пустого проекта с помощью Мастера проектов . Новые проекты, начинающиеся с шаблонов, могут также создавать файлы конфигурации DefaultEditor.ini и DefaultInput.ini, если это необходимо.&lt;/p&gt;
&lt;h2 id=&#34;указание-настраиваемых-переменных&#34;&gt;Указание настраиваемых переменных:&lt;/h2&gt;
&lt;p&gt;Чтобы указать, какие переменные следует считывать из файлов конфигурации, класс, содержащий эти переменные, должен сначала получить спецификатор Config в своем макросе UCLASS.&lt;/p&gt;
&lt;p&gt;Украшение класса спецификатором Config просто указывает, что этот класс может иметь переменные, считанные из файлов конфигурации, и указывает, из каких файлов считываются конфигурации. Чтобы указать конкретную переменную как прочитанную и сохраненную в файле конфигурации, спецификатор Config также должен быть предоставлен макросу UPROPERTY().&lt;/p&gt;
&lt;h2 id=&#34;файлы-конфигурации-и-наследование&#34;&gt;Файлы конфигурации и наследование:&lt;/h2&gt;
&lt;p&gt;Спецификаторы Config, UCLASS и UPROPERTY наследуются. Это означает, что дочерний класс может либо считывать, либо сохранять все переменные, указанные как Config в родительском классе, и они будут в той же категории файла конфигурации. Все переменные будут находиться под заголовком раздела с именем дочернего класса. Например, информация файла конфигурации для ChildExampleClass, который наследуется от приведенного выше класса ExampleClass, будет выглядеть как следующие строки и сохраняться в тех же файлах конфигурации игры.&lt;/p&gt;
&lt;h2 id=&#34;конфигурации-для-каждого-экземпляра&#34;&gt;Конфигурации для каждого экземпляра:&lt;/h2&gt;
&lt;p&gt;Каждая категория конфигурации имеет свою собственную иерархию файлов, в которых указаны конфигурации для конкретного движка, проекта и платформы.&lt;/p&gt;
&lt;p&gt;Категории конфигурации:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compat&lt;/li&gt;
&lt;li&gt;DeviceProfiles&lt;/li&gt;
&lt;li&gt;Editor&lt;/li&gt;
&lt;li&gt;EditorGameAgnostic&lt;/li&gt;
&lt;li&gt;EditorKeyBindings&lt;/li&gt;
&lt;li&gt;EditorUserSettings&lt;/li&gt;
&lt;li&gt;Engine&lt;/li&gt;
&lt;li&gt;Game&lt;/li&gt;
&lt;li&gt;Input&lt;/li&gt;
&lt;li&gt;Lightmass&lt;/li&gt;
&lt;li&gt;Scalability&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;иерархия-файлов&#34;&gt;Иерархия файлов:&lt;/h2&gt;
&lt;p&gt;Иерархия файла конфигурации считывается, начиная с Base.ini, при этом значения в более поздних файлах иерархии переопределяют более ранние значения. Все файлы в папке Engine будут применяться ко всем проектам, а настройки для конкретных проектов должны находиться в файлах в каталоге проекта. Наконец, все различия, специфичные для проекта и платформы, сохраняются в [ProjectDirectory]/Saved/Config/[Platform]/[Category].ini.&lt;/p&gt;
&lt;p&gt;Приведенный ниже пример файловой иерархии относится к категории файлов конфигурации Engine.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Engine/Config/Base.ini&lt;/li&gt;
&lt;li&gt;Engine/Config/BaseEngine.ini&lt;/li&gt;
&lt;li&gt;Engine/Config/[Platform]/base[Platform]Engine.ini&lt;/li&gt;
&lt;li&gt;[ProjectDirectory]/Config/DefaultEngine.ini&lt;/li&gt;
&lt;li&gt;Engine/Config/[Platform]/[Platform]Engine.ini&lt;/li&gt;
&lt;li&gt;[ProjectDirectory]/Config/[Platform]/[Platform]Engine.ini&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;комментарии&#34;&gt;Комментарии:&lt;/h2&gt;
&lt;p&gt;У большинства людей сложилось впечатление, что точка с запятой обозначает комментарии в файлах конфигурации, но это не так (FConfigFile::ProcessInputFileContents на самом деле не рассматривает их или любую другую строку как разделитель комментариев). Такое поведение является преднамеренным. Технически любой символ может представлять другую пару ключ-значение. Обычно точка с запятой ставится в начале новой строки. Это работает как комментарий, но на самом деле это не так.&lt;/p&gt;
&lt;h2 id=&#34;итоги-работы&#34;&gt;Итоги работы&lt;/h2&gt;
&lt;p&gt;По итогу работы я познакомился с файлами конфигурации и методами работы с ними.&lt;/p&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;Copyright 2022-present &lt;a href=&#34;https://4ebupelinka.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Борис Тараканов&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Released under the &lt;a href=&#34;https://github.com/wowchemy/wowchemy-hugo-modules/blob/master/LICENSE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Пост по прошлой неделе</title>
      <link>https://example.com/post/%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D0%BE-%D0%BF%D1%80%D0%BE%D1%88%D0%BB%D0%BE%D0%B8-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5-3/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/post/%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D0%BE-%D0%BF%D1%80%D0%BE%D1%88%D0%BB%D0%BE%D0%B8-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5-3/</guid>
      <description>&lt;h2 id=&#34;о-виджетах&#34;&gt;О виджетах:&lt;/h2&gt;
&lt;p&gt;Виджет (widget) — это элемент UI, предоставляющий UI визуальные функции. Например, виджет Button предоставляет объект, который пользователь может видеть и нажимать на него.
Сам виджет необязательно должен быть видимым. Например, виджет Grid Panel равномерно разделяет своё пространство между его содержимым. Пользователь не может увидеть Grid Panel, но видит его воздействие.
Можно даже создать виджет, являющийся целым интерфейсом, например, экраном меню. Ниже представлен пример виджета, созданного так, чтобы он выглядел как начальный экран игры. Все элементы UI тоже являются виджетами и содержатся внутри виджета начального экрана.&lt;/p&gt;
&lt;h2 id=&#34;создание-виджета&#34;&gt;Создание виджета:&lt;/h2&gt;
&lt;p&gt;Перейдем в Content Browser и найдем папку UI. Нажмем на кнопку Add New и выберем User Interface\Widget Blueprint. Переименуем новый ассет в WBP_HUD.&lt;/p&gt;
&lt;h2 id=&#34;umg-ui-designer&#34;&gt;UMG UI Designer:&lt;/h2&gt;
&lt;p&gt;UMG UI Designer состоит из семи основных элементов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Designer: в этой области представлено визуальное отображение виджета. Перемещаться по ней можно зажав правую клавишу мыши и двигая мышью. Масштабирование выполняется прокруткой колёсика мыши.&lt;/li&gt;
&lt;li&gt;Details: здесь отображаются свойства выбранного виджета&lt;/li&gt;
&lt;li&gt;Palette: список всех виджетов, которые можно использовать. Все созданные пользователем виджеты тоже появляются здесь.&lt;/li&gt;
&lt;li&gt;Hierarchy: список всех уже используемых виджетов&lt;/li&gt;
&lt;li&gt;Animations: некоторые свойства виджетов могут иметь анимацию, например, расположение и размер. В этой панели перечислены все анимации.&lt;/li&gt;
&lt;li&gt;Timeline: при выборе анимации на этой панели показываются анимированные свойства и ключевые кадры&lt;/li&gt;
&lt;li&gt;Editor Mode: здесь можно переключаться между режимами Designer и Graph. Режим Graph почти аналогичен Event Graph у Blueprint.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;привязки&#34;&gt;Привязки:&lt;/h2&gt;
&lt;p&gt;Точка привязки задаёт место, относительно которого определяется положение виджета. По умолчанию виджеты привязаны к верхнему левому углу своего родительского элемента. Поэтому когда мы задаём положение виджета, мы на самом деле указывает положение относительно этой точки привязки.
Заметьте, что каждое изображение сохраняет положение относительно своей привязки. Благодаря привязкам UI будет иметь одинаковое расположение при разных размерах экрана.
Также можно использовать привязки для автоматического изменения размера виджетов. В случае привязки к двум или более точкам виджет будет менять свой размер для сохранения относительного размера.&lt;/p&gt;
&lt;h2 id=&#34;отображение-hud&#34;&gt;Отображение HUD:&lt;/h2&gt;
&lt;p&gt;Нажмем на Compile, а затем вернемся в основной редактор. Перейдем в папку Blueprints и дважды щёлкнем на BP_GameManager, чтобы открыть его.
HUD должен становиться видимым после запуска игры. Для этого можно использовать нод Event BeginPlay.
Найдем нод Event BeginPlay и добавим нод Create Widget в конец цепочки нодов. Этот нод создаёт экземпляр указанного виджета.
Нажмем на раскрывающийся список рядом с Class и выберем WBP_HUD.&lt;/p&gt;
&lt;p&gt;Давайте разберёмся с порядком событий:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Когда Unreal спаунит BP_GameManager, выполняются функции Restart и SetUpCamera. Эти функции настраивают несколько переменных и камеру. Если вы не знаете, что такое функция, то не волнуйтесь, скоро мы их рассмотрим.&lt;/li&gt;
&lt;li&gt;Нод Create Widget создаёт экземпляр WBP_HUD&lt;/li&gt;
&lt;li&gt;Нод Add to Viewport отображает WBP_HUD&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;итоги-работы&#34;&gt;Итоги работы&lt;/h2&gt;
&lt;p&gt;По итогам работы я научился следующему:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Создавать HUD-дисплей, на котором отображается счётчик и таймер&lt;/li&gt;
&lt;li&gt;Отображать HUD на экране&lt;/li&gt;
&lt;li&gt;Обновлять счётчик и таймер, чтобы отображать значения переменных&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;Copyright 2022-present &lt;a href=&#34;https://4ebupelinka.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Борис Тараканов&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Released under the &lt;a href=&#34;https://github.com/wowchemy/wowchemy-hugo-modules/blob/master/LICENSE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Пост по прошлой неделе</title>
      <link>https://example.com/post/%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D0%BE-%D0%BF%D1%80%D0%BE%D1%88%D0%BB%D0%BE%D0%B8-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5-2/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/post/%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D0%BE-%D0%BF%D1%80%D0%BE%D1%88%D0%BB%D0%BE%D0%B8-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5-2/</guid>
      <description>&lt;h2 id=&#34;что-такое-wm&#34;&gt;Что такое WM?&lt;/h2&gt;
&lt;p&gt;World Machine помогает создавать реалистичные 3D-рельефы. Мощная и гибкая программа World Machine сочетает процедурное создание рельефа, моделирование природы и интерактивное редактирование для быстрого и простого создания реалистичного рельефа. Вы можете создавать и экспортировать поля высот, текстуры и сетки высокого разрешения для игр или программ рендеринга.&lt;/p&gt;
&lt;h2 id=&#34;почему-именно-wm&#34;&gt;Почему именно WM?&lt;/h2&gt;
&lt;p&gt;Несмотря на то что игровой движок, который я использую, имеет встроенные средства для создания и редактирования ландшафта, они подразумевают использование вручную, что неэффективно в контексте создания цельного игрового мира, имеющего размеры порядка 60 квадратных километров. Так же имеются программы аналогичные данной, но WM является наиболее узнаваемой, в силу чего для нее легче найти инструкции по использованию.&lt;/p&gt;
&lt;h2 id=&#34;как-это-устроено&#34;&gt;Как это устроено?&lt;/h2&gt;
&lt;p&gt;В отличие от традиционных редакторов рельефа на основе кистей, World Machine использует процедурный подход. Формируйте рельеф, используя основные строительные блоки, такие как фракталы, затем дополните их симуляцией природы, чтобы создать реалистичные черты.
Просто соедините вместе блоки действий, чтобы создать свой мир.
Вот великолепный пейзаж, созданный менее чем за две минуты.&lt;/p&gt;
&lt;h2 id=&#34;итоги-работы&#34;&gt;Итоги работы&lt;/h2&gt;
&lt;p&gt;За прошлую неделю я изучил основные возможности программы World Machine, в том числе:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Использование нод шума для создания основы ландшафта&lt;/li&gt;
&lt;li&gt;Использование инструмента Layout Generator&lt;/li&gt;
&lt;li&gt;Использование инструментов: эррозия, кривые, комбинирование, фильтры.&lt;/li&gt;
&lt;li&gt;Экспорт карт высот и текстур в заданном разрешении&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;Copyright 2022-present &lt;a href=&#34;https://4ebupelinka.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Борис Тараканов&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Released under the &lt;a href=&#34;https://github.com/wowchemy/wowchemy-hugo-modules/blob/master/LICENSE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Пост по прошлой неделе</title>
      <link>https://example.com/post/%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D0%BE-%D0%BF%D1%80%D0%BE%D1%88%D0%BB%D0%BE%D0%B8-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5-1/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/post/%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D0%BE-%D0%BF%D1%80%D0%BE%D1%88%D0%BB%D0%BE%D0%B8-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5-1/</guid>
      <description>&lt;h2 id=&#34;что-такое-rvt&#34;&gt;Что такое RVT?&lt;/h2&gt;
&lt;p&gt;Runtime Virtual Texture (RVT) создает свои текстурные данные по требованию с помощью GPU во время выполнения и работает аналогично традиционному текстурированию. RVT кэширует данные о затенении на больших площадях, что делает их подходящими для затенения ландшафта, где используются материалы, похожие на декали, и сплайны, которые хорошо подходят для соответствия рельефу.&lt;/p&gt;
&lt;h2 id=&#34;для-настройки-и-использования-виртуального-текстурирования-среды-выполнения-в-проекте-выполните-следующие-высокоуровневые-действия-&#34;&gt;Для настройки и использования виртуального текстурирования среды выполнения в проекте выполните следующие высокоуровневые действия: :&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Создайте виртуальный текстурный ресурс (ы) среды выполнения в браузере содержимого. Он используется для связи всех компонентов (актеров, тома RVT и материалов RVT) вместе для рендеринга виртуальной текстуры среды выполнения.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Добавьте виртуальный текстурный том среды выполнения в сцену с панели Режимы. Это используется для размещения актива RVT в сцене.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Настройте свои материалы для записи в ресурс RVT.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Настройте материалы для отбора проб из актива RVT.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Настройте один или несколько примитивов или ландшафтных актеров для рендеринга в актив RVT.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;зачем-нужны-виртуальные-текстуры-реального-времени&#34;&gt;Зачем нужны виртуальные текстуры реального времени?&lt;/h2&gt;
&lt;p&gt;Данный вид текстур используется в частности для создание правдоподобного окружения в игровом мире, так как позволяет сгладить преход можду текступой ланшафта и текстурой объекта, например камня. Так же виртруальные текстуры реального времени можно использовать для создания поверхности ланшафта, реагируещей на другие объекты (например снег, который приминается под ногой игрового персоонажа), использование именно метода RVT для данной задачи, является выигрышным со стороны производиительности, потому что не создается полигональная сетка высокой плотности, нагружающая систему, а взаимодействие происходит на уровне ландшафта.&lt;/p&gt;
&lt;h2 id=&#34;итоги-работы&#34;&gt;Итоги работы&lt;/h2&gt;
&lt;p&gt;Мне удалось создать и настроить RVT для создания правдоподобного окружения(Плавный переход текстуры ландшафта в текстуру камня, зозданного методом 3D сканирования), в будущем я планирую использовать RVT для создания ландшафтного материала, реагирующего на действия игрока, в частности снег и грязь.&lt;/p&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;Copyright 2022-present &lt;a href=&#34;https://4ebupelinka.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Борис Тараканов&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Released under the &lt;a href=&#34;https://github.com/wowchemy/wowchemy-hugo-modules/blob/master/LICENSE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
